// ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
// ┃ 🔮 ritual_invoker_service.dart - Executor de rituais e gerador de artefatos ┃
// ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

import 'dart:io';
import 'package:path/path.dart' as p;

class RitualInvokerService {
  final String recipesPath;
  final String outputPath;

  RitualInvokerService({
    required this.recipesPath,
    required this.outputPath,
  });

  Future<void> conjureAll() async {
    final Directory dir = Directory(recipesPath);

    if (!await dir.exists()) {
      print('⚠️ Pasta de receitas não encontrada: $recipesPath');
      return;
    }

    final List<FileSystemEntity> files = dir
        .listSync(recursive: true)
        .where((f) => f is File && f.path.endsWith('.txt'))
        .toList();

    if (files.isEmpty) {
      print('⏳ Nenhuma receita encontrada.');
      return;
    }

    for (final file in files) {
      final String name = p.basenameWithoutExtension(file.path);
      final String content = await File(file.path).readAsString();

      if (content.trim().isEmpty) {
        print('⚠️ Receita vazia: ${file.path}');
        continue;
      }

      final String artifact = _transform(content);
      final String outputFile = p.join(outputPath, '$name.dart');

      await File(outputFile).writeAsString(artifact);
      print('✅ Artefato gerado: $outputFile');
    }
  }

  String _transform(String ritualText) {
    // Simulação de transformação mágica
    return '''
// 🔮 Artefato gerado automaticamente
void main() {
  print("Executando ritual: ${ritualText.replaceAll('"', '\\"')}");
}
''';
  }
}

// Sugestões
// - 🛡️ Validar sintaxe dos rituais antes de transformar
// - 🔤 Adicionar suporte a múltiplos formatos de entrada (ex: YAML, JSON)
// - 📦 Integrar com storage para registrar histórico de execuções
// - 🧩 Criar sistema de rollback para desfazer artefatos inválidos
// - 🎨 Expor status visual para UI com animações de conjuração

// ✍️ byThyrrel  
// 💡 Código formatado com estilo técnico, seguro e elegante  
// 🧪 Ideal para conjuradores de código com foco em automação limpa e confiável
